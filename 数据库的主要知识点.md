

数据库的主要知识点：

# 一、数据库的索引，索引相关知识，索引优化



# 二、数据库的锁分类以及常见知识考点

区别于文件系统的区别，一个是锁机制，一个是事务机制（事务的隔离级别)

锁升级：锁的粒度增大，为了克服竞争，行锁转换为表锁

innodb是行锁，MyIASM是表锁。



## 常见的Lock与latch两种锁的区别：

latch 对象是线程，锁住的是共享资源：

(门闩，轻量级锁)，分为互斥量和读写锁，数据库用来控制线程进入共享资源的方法，没有死锁的循环检测。

lock的对象，数据库的事务。资源是数据库的行，页，表：

有死锁检测机制，lock的资源在事务的commit和rollBack的时候做回滚



## innodb的行锁分类：

共享锁S,

排他锁X,

innoDB支持一种额外的锁叫做意向锁，（为了在一个事务中揭示下一行将被请求的锁类型）

IS:事务想要获得表的某几行的共享锁

IX:事务想要获得表中的某几行的排他锁，几种锁的互斥性

|      | IS     | IX     | S      | X      |
| ---- | ------ | ------ | ------ | ------ |
| IS   | 兼容   | 兼容   | 兼容   | 不兼容 |
| IX   | 兼容   | 兼容   | 不兼容 | 不兼容 |
| S    | 兼容   | 不兼容 | 兼容   | 不兼容 |
| X    | 不兼容 | 不兼容 | 不兼容 | 不兼容 |

### **非一致性锁定读机制，是innoDB的默认读取方式：**

这种数据库的机制下（读取版本数据），不需要等待表上的锁和行上的锁，可以提高数据库的并发读。但是在不同的数据库隔离机制下，读取方式也不同。在innodb的默认隔离级别RepeateBle和read commited中，非一致性读取（**读取快照数据，克服脏读，但是两者读取快照数据类型不同**）。

一致性锁定读：对数据的读取手动去加上锁！！！！！！！！！！！！！！！

select .....FOR UPDATE,读取的时候加上X锁，其他事务不能对上锁的数据进行操作

select .....LOCK IN SHARE MODE,读取的时候加上s锁，其他事务不能修改。

这两种操作要在一个事务中进行，事务结束之后！锁释放！！！！！



### **锁的三种算法：**

RecordLock: 单个记录上的行锁

GapLock: 锁定一个范围的记录，

**Next-Key_lock：**锁定一个范围加上本身行的记录（解决幻读的问题），这种锁是针*<u>**对事务在读取数据**</u>*的时候引起的幻读问题，而提出的方案！很有效！**innodb默认的机制**



### **数据库的死锁问题**

**死锁的定义** 事务A 操作表a上锁x,接着要访问表b,事务B先访问b表上了x锁，然后访问表a，会造成死锁的问题

**死锁解决思路：**

1、所有事务不需要等待，直接回滚，数据库的压力大，而且可能造成一直死锁一直回滚

2、超时回滚，给事务设置超时时间，超时之后自动回滚可以解决，但是如果按照FIFO的规则，即先申请的事务先回滚，有可能事务的权重不一样，回滚的耗费资源也不一样（redo和undo的日志信息）（被动）

3、wait-for-graph的算法实现，主动检测是否有回环（深度优先遍历），死锁机制。然后选择undo量最小的事务进行回滚。



# 三、数据库的事务

ＡＣＩＤs四个数据库的特性：

分类：

扁平事务：最常见的事务，失败之后全部回滚，没有保存点，缺点

带有保存节点的扁平事务：

链接事务：变种的带有保存节点的扁平事务

嵌套事务：

分布式事务：

# 四、数据库的隔离级别机制(强调事务之间的隔离性)

1 、read uncommited会造成脏读，不可重复读、幻读等问题，完全不推荐

A事务操作a数据------>在A事务中B事务拿到a的值为A未提交的脏数据-->B提交事务---->A提交事务

2、read commited 不会造成脏读，会有不可重复读，幻读，oracle默认级别（非一致性锁定记录读取，读取的快照是最新的一份）

A事务操作读取a值----->在A事务中启B事务改变a的值-->B提交事务---->A事务读取a的值，前后不一致，不可重复读

3、Repeateable 会有幻读，但是不会有不可重复读**，innodb,mysql默认级别，使用了范围锁解决幻读**

**A事务读取某个值（非一致性读取的数据记录是快照的初始版本，进入事务的第一个快照）**